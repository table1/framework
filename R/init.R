#' Create init.R from template
#' @keywords internal
.create_init_file <- function(project_name, type, lintr, subdir = NULL) {
  template_path <- system.file("templates/init.fr.R", package = "framework")
  if (!file.exists(template_path)) {
    stop("Template init.fr.R not found in package")
  }

  content <- readLines(template_path, warn = FALSE)

  # Replace placeholders
  content <- gsub("\\{\\{PROJECT_NAME\\}\\}", project_name, content)
  content <- gsub("\\{\\{PROJECT_TYPE\\}\\}", type, content)
  content <- gsub("\\{\\{LINTR\\}\\}", lintr, content)

  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  target_file <- file.path(target_dir, "init.R")

  writeLines(content, target_file)
  message(sprintf("Created %s", target_file))
}

#' Create config.yml from template
#' @keywords internal
.create_config_file <- function(type = "analysis", attach_defaults = TRUE, subdir = NULL) {
  # Try type-specific template first, fall back to generic
  template_name <- sprintf("templates/config.%s.fr.yml", type)
  template_path <- system.file(template_name, package = "framework")

  if (!file.exists(template_path)) {
    # Fall back to generic template
    template_path <- system.file("templates/config.fr.yml", package = "framework")
    if (!file.exists(template_path)) {
      stop("Template config.fr.yml not found in package")
    }
  }

  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  target_file <- file.path(target_dir, "config.yml")

  # Read template content
  content <- readLines(template_path, warn = FALSE)

  # If attach_defaults is TRUE, replace the packages section with structured format
  if (attach_defaults) {
    # Find the packages section
    packages_start <- grep("^\\s*packages:", content)
    if (length(packages_start) > 0) {
      # Find where packages section ends (next section or end of file)
      section_headers <- grep("^\\s*[a-z_]+:", content)
      next_section <- section_headers[section_headers > packages_start[1]]
      packages_end <- if (length(next_section) > 0) next_section[1] - 1 else length(content)

      # Remove old packages section
      content <- content[-(packages_start:packages_end)]

      # Insert new structured packages section
      new_packages <- c(
        "  packages:",
        "    # Auto-attached packages (available without library() calls)",
        "    - name: dplyr",
        "      attached: true",
        "    - name: tidyr",
        "      attached: true",
        "    - name: ggplot2",
        "      attached: true",
        "    # Installed but not auto-attached (use library() when needed)",
        "    - name: readr",
        "      attached: false",
        "    - name: stringr",
        "      attached: false",
        "    - name: scales",
        "      attached: false",
        ""
      )

      # Insert at the packages_start position
      content <- c(
        content[1:(packages_start - 1)],
        new_packages,
        content[packages_start:length(content)]
      )
    }
  }

  # Write modified content
  writeLines(content, target_file)
  message(sprintf("Created %s", target_file))
}

#' Create development .Rprofile
#' @keywords internal
.create_dev_rprofile <- function(subdir = NULL) {
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  target_file <- file.path(target_dir, ".Rprofile")

  # Get the user's home directory
  home_dir <- Sys.getenv("HOME")
  framework_dev_path <- file.path(home_dir, "code", "framework")

  rprofile_content <- sprintf('# Development .Rprofile for Framework
# Auto-generated by init(.dev_mode = TRUE)
# This .Rprofile overrides library() to load framework from development directory

# Store original library function
original_library <- base::library

# Override library function
library <- function(package, help = NULL, pos = 2, lib.loc = NULL,
                    character.only = FALSE, logical.return = FALSE,
                    warn.conflicts = TRUE, quietly = FALSE,
                    verbose = getOption("verbose")) {

  # Get the package name
  if (!character.only) {
    package <- as.character(substitute(package))
  }

  # If it\'s framework, use our custom loading
  if (package == "framework") {
    # First try to load from development directory
    dev_path <- "%s"
    if (dir.exists(dev_path)) {
      if (requireNamespace("devtools", quietly = TRUE)) {
        env <- devtools::load_all(dev_path, export_all = FALSE, quiet = TRUE)
        message("Framework loaded from development directory: ", dev_path)
        return(invisible(env))
      } else {
        warning("devtools package required for dev_mode. Install with: install.packages(\\"devtools\\")")
      }
    }

    # If not in development, try to load as installed package
    if (requireNamespace("framework", quietly = TRUE)) {
      original_library("framework", character.only = TRUE, quietly = quietly,
                      warn.conflicts = warn.conflicts)
      message("Framework loaded from installed package")
      return(invisible(TRUE))
    }

    warning("Framework not found - neither in ", dev_path, " nor as installed package")
    return(invisible(NULL))
  }

  # For all other packages, use the original library function
  original_library(package = package, help = help, pos = pos, lib.loc = lib.loc,
                  character.only = TRUE, logical.return = logical.return,
                  warn.conflicts = warn.conflicts, quietly = quietly,
                  verbose = verbose)
}

message("Framework dev mode active - will load from: %s")
', framework_dev_path, framework_dev_path)

  writeLines(rprofile_content, target_file)
  message(sprintf("Created development .Rprofile: %s", target_file))
  message(sprintf("  Framework will load from: %s", framework_dev_path))
}


#' Delete init.R after successful initialization
#' @keywords internal
.delete_init_file <- function(subdir = NULL) {
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  init_file <- file.path(target_dir, "init.R")

  # Only delete if init.R exists
  if (!file.exists(init_file)) {
    return(invisible(NULL))
  }

  # Delete init.R
  tryCatch({
    file.remove(init_file)
    message("\u2713 Cleaned up init.R (use make_init() to recreate for reference)")
  }, error = function(e) {
    warning(sprintf("Could not delete init.R: %s", e$message))
  })

  invisible(NULL)
}

#' Display next steps after initialization
#' @keywords internal
.display_next_steps <- function(project_name = NULL, type = "project", use_renv = FALSE) {
  cat("\n")
  cat("\u2713 Framework project initialized successfully!\n\n")

  # Show summary of settings
  cat("Project Configuration:\n")
  if (!is.null(project_name)) {
    cat(sprintf("  • Name: %s\n", project_name))
  }
  cat(sprintf("  • Type: %s\n", type))
  cat(sprintf("  • renv: %s\n", if (use_renv) "enabled" else "disabled"))
  cat("\n")

  cat("Next steps:\n")
  cat("  1. Review and edit config.yml\n")
  cat("  2. Start a new R session in this directory\n")
  cat("  3. Run:\n")
  cat("       library(framework)\n")
  cat("       scaffold()\n")
  cat("  4. Start analyzing!\n\n")
  cat("Optional:\n")
  cat("  • Add database connections: configure_connection()\n")
  cat("  • Store secrets: make_env(VAR_NAME = \"value\")\n\n")

  # Additional context based on project type
  if (type == "course") {
    cat("Course-specific features:\n")
    cat("  • lectures/ - For lecture materials and slides\n")
    cat("  • assignments/ - For student assignments\n")
    cat("  • Use make_notebook() to create student notebooks\n\n")
  } else if (type == "presentation") {
    cat("Presentation tips:\n")
    cat("  • Use make_notebook() to create your presentation\n")
    cat("  • Quarto reveal.js format recommended\n\n")
  }
}

#' Initialize the framework
#'
#' This function initializes the framework for a new project.
#' Can be run from the framework-project template OR from any empty directory.
#' When run from an empty directory, requires project_name and type parameters.
#'
#' @param project_name The name of the project (used for .Rproj file). Required when initializing from empty directory.
#' @param type The project type: "project" (default), "course", or "presentation".
#'   Replaces deprecated project_structure parameter.
#' @param project_structure DEPRECATED. Use 'type' parameter instead.
#'   For backward compatibility: "default"/"minimal" map to "project"/"presentation".
#' @param lintr The lintr style to use.
#' @param use_renv If TRUE, enables renv for package management. Default FALSE.
#' @param use_git If TRUE, initializes a git repository. Default TRUE.
#' @param attach_defaults If TRUE, configures default packages to auto-attach on scaffold().
#'   Default packages: dplyr, tidyr, ggplot2 (auto-attached), readr, stringr, scales (installed only).
#'   Default TRUE.
#' @param subdir Optional subdirectory to copy files into. If provided, {subdir} in config files will be replaced with subdir/.
#' @param force If TRUE, will reinitialize even if project is already initialized.
#'
#' @examples
#' \dontrun{
#' # Initialize with explicit parameters
#' init(
#'   project_name = "MyProject",
#'   type = "project",
#'   use_renv = FALSE,
#'   attach_defaults = TRUE
#' )
#'
#' # Course project with renv enabled
#' init(
#'   project_name = "MyCourse",
#'   type = "course",
#'   use_renv = TRUE
#' )
#'
#' # Single presentation without default packages
#' init(type = "presentation", attach_defaults = FALSE)
#' }
#'
#' @export
init <- function(
    project_name = NULL,
    type = NULL,
    project_structure = NULL,
    lintr = NULL,
    use_renv = FALSE,
    use_git = TRUE,
    attach_defaults = TRUE,
    author_name = NULL,
    author_email = NULL,
    author_affiliation = NULL,
    default_notebook_format = NULL,
    subdir = NULL,
    force = FALSE,
    .dev_mode = FALSE) {
  # Handle deprecated project_structure parameter
  if (!is.null(project_structure) && is.null(type)) {
    warning(
      "Parameter 'project_structure' is deprecated. Use 'type' instead.\n",
      "  Mapping: 'default' -> 'project', 'minimal' -> 'presentation'"
    )
    type <- switch(project_structure,
      "default" = "project",
      "minimal" = "presentation",
      "project"  # fallback
    )
  }

  # Handle deprecated "analysis" type
  if (!is.null(type) && type == "analysis") {
    warning(
      "Type 'analysis' is deprecated. Use 'project' instead.\n",
      "  The 'analysis' type will be removed in a future version."
    )
    type <- "project"
  }

  # Validate arguments
  checkmate::assert_string(project_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(type, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(project_structure, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(lintr, min.chars = 1, null.ok = TRUE)
  checkmate::assert_flag(use_renv)
  checkmate::assert_flag(use_git)
  checkmate::assert_flag(attach_defaults)
  checkmate::assert_string(author_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_email, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_affiliation, min.chars = 1, null.ok = TRUE)
  # Handle empty string as NULL for validation
  if (!is.null(default_notebook_format) && nzchar(default_notebook_format)) {
    checkmate::assert_choice(default_notebook_format, c("quarto", "rmarkdown"))
  } else {
    default_notebook_format <- NULL
  }
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)
  checkmate::assert_flag(force)

  # Check if already initialized (by checking for config.yml)
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  config_file <- file.path(target_dir, "config.yml")
  if (file.exists(config_file) && !force) {
    stop("Project already initialized (config.yml exists). Use force = TRUE to reinitialize.")
  }

  # Detect if running from template (has init.R) or empty directory
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  from_template <- file.exists(file.path(target_dir, "init.R"))

  # If from empty directory, create necessary files first
  if (!from_template) {
    message("Initializing from empty directory...")

    # Require project_name and type
    if (is.null(project_name) || is.null(type)) {
      stop("project_name and type are required when initializing from an empty directory")
    }

    # Set defaults for optional parameters
    if (is.null(lintr)) lintr <- "default"

    # Create foundational files
    .create_init_file(project_name, type, lintr, subdir)
    .create_config_file(type, attach_defaults, subdir)
  } else {
    # Set defaults from template behavior
    if (is.null(type)) type <- "project"
    if (is.null(lintr)) lintr <- "default"
  }

  # Continue with standard init process (without git init)
  .init_standard(project_name, type, lintr, author_name, author_email, author_affiliation, default_notebook_format, subdir, force, FALSE)

  # Enable renv if requested
  if (use_renv) {
    message("Enabling renv for this project...")
    renv_enable()
  }

  # Create dev mode .Rprofile if requested
  if (.dev_mode) {
    .create_dev_rprofile(subdir)
  }

  # Delete init.R after successful initialization
  .delete_init_file(subdir)

  # Clean up .gitkeep files from data/ and functions/
  .cleanup_gitkeep_files(target_dir)

  # Initialize git AFTER archiving so all files are in final state
  if (use_git) {
    .init_git_repo(target_dir)
  }

  # Prompt for AI assistant support (if enabled by user)
  assistants <- .prompt_ai_support_init()
  if (length(assistants) > 0) {
    .create_ai_instructions(assistants, target_dir, project_name)
  }

  # Display next steps if from empty directory
  if (!from_template) {
    .display_next_steps(project_name, type, use_renv)
  }
}

#' Standard initialization process (shared by both paths)
#' @keywords internal
.init_standard <- function(project_name, type, lintr, author_name = NULL, author_email = NULL, author_affiliation = NULL, default_notebook_format = NULL, subdir, force, use_git = TRUE) {
  # Validate arguments (already validated in init, but keep for internal calls)
  checkmate::assert_string(project_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(type, min.chars = 1)
  checkmate::assert_string(lintr, min.chars = 1)
  checkmate::assert_string(author_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_email, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_affiliation, min.chars = 1, null.ok = TRUE)
  # Handle empty string as NULL
  if (!is.null(default_notebook_format) && !nzchar(default_notebook_format)) {
    default_notebook_format <- NULL
  }
  if (!is.null(default_notebook_format)) {
    checkmate::assert_choice(default_notebook_format, c("quarto", "rmarkdown"))
  }
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)
  checkmate::assert_flag(force)

  # NOTE: init() already checked for config.yml, no need to check again here
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."

  # Derive project name
  if (!is.null(project_name)) {
    # Keep original capitalization, just convert spaces to hyphens for filenames
    rproj_name <- gsub("\\s+", "-", project_name)
  } else {
    project_name <- basename(getwd())
    rproj_name <- project_name
  }

  # Validate template style files
  lintr_template <- system.file("templates", paste0(".lintr.", lintr, ".fr"), package = "framework")
  if (!file.exists(lintr_template)) stop(sprintf("Lintr style '%s' not found", lintr))

  # Remove existing *.Rproj file (only one per project)
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  existing_rproj <- list.files(path = target_dir, pattern = "\\.Rproj$", full.names = TRUE)
  if (length(existing_rproj)) file.remove(existing_rproj)

  # Copy and rename .Rproj file
  rproj_template <- system.file("templates", "project.fr.Rproj", package = "framework")
  if (!file.exists(rproj_template)) stop("Template project.fr.Rproj file not found in package.")
  rproj_target <- file.path(target_dir, paste0(rproj_name, ".Rproj"))
  file.copy(rproj_template, rproj_target, overwrite = TRUE)

  # Create IDE configuration files (VS Code workspace and settings)
  .create_ide_configs(rproj_name, target_dir, python = FALSE)

  # Copy and rename other template files
  template_dir <- system.file("templates", package = "framework")
  template_files <- list.files(template_dir, full.names = TRUE, all.files = TRUE, no.. = TRUE)

  for (file in template_files) {
    fname <- basename(file)

    # Skip files already handled explicitly
    if (fname == "project.fr.Rproj") next
    if (fname == "init.fr.R") next  # Skip init.R template (handled separately in empty dir case)
    if (fname == ".env.fr") next  # Skip .env template (removed, use make_env() instead)
    if (fname == "test.fr.R") next  # Skip test file template

    # Skip type-specific config and README files
    if (grepl("^config\\.(project|course|presentation)\\.fr\\.yml$", fname)) next
    if (grepl("^README.*\\.fr\\.md$", fname)) next  # Skip all README templates (now in project_structure)
    if (fname == "config.fr.yml") next  # Skip generic config (handled separately)

    if (!grepl("\\.fr($|\\.)", fname)) next

    # Replace `.fr.` with `.` or `.fr` suffix with nothing
    new_name <- gsub("\\.fr\\.", ".", fname)
    new_name <- gsub("\\.fr$", "", new_name)
    # Remove .default from lintr files (both in middle and end)
    new_name <- gsub("\\.default\\.", ".", new_name)
    new_name <- gsub("\\.default$", "", new_name)

    # Preserve leading dot
    if (grepl("^\\.", fname)) {
      new_name <- paste0(".", sub("^\\.", "", new_name))
    }

    target_path <- file.path(target_dir, new_name)
    dir.create(dirname(target_path), showWarnings = FALSE, recursive = TRUE)

    success <- file.copy(file, target_path, overwrite = TRUE)
    if (!success) warning(sprintf("Failed to copy template file: %s to %s", file, target_path))

    # Substitute {subdir} in YAML-like config files
    if (grepl("\\.ya?ml$", new_name)) {
      content <- readLines(target_path)
      subdir_prefix <- if (!is.null(subdir) && nzchar(subdir)) paste0(subdir, "/") else ""
      content <- gsub("\\{subdir\\}", subdir_prefix, content)
      writeLines(content, target_path)
    }
  }

  # Copy project structure
  structure_dir <- system.file("project_structure", type, package = "framework")
  if (!dir.exists(structure_dir)) stop(sprintf("Project type '%s' not found", type))

  all_dirs <- list.dirs(structure_dir, recursive = TRUE, full.names = TRUE)
  all_dirs <- all_dirs[all_dirs != structure_dir]

  for (dir in all_dirs) {
    rel_path <- sub(paste0("^", structure_dir, "/?"), "", dir)
    target_path <- file.path(target_dir, rel_path)
    dir.create(target_path, showWarnings = FALSE, recursive = TRUE)
  }

  structure_files <- list.files(structure_dir, recursive = TRUE, full.names = TRUE, all.files = TRUE)
  for (file in structure_files) {
    rel_path <- sub(paste0("^", structure_dir, "/?"), "", file)

    # Skip connections.yml for presentation projects (no database by default)
    if (type == "presentation" && grepl("settings/connections\\.yml$", rel_path)) {
      next
    }

    target_path <- file.path(target_dir, rel_path)
    file.copy(file, target_path, overwrite = TRUE)
  }

  # README.md is now part of project_structure and copied above

  # Update config.yml with author information and notebook format if provided
  has_author_info <- (!is.null(author_name) && nzchar(author_name)) ||
                      (!is.null(author_email) && nzchar(author_email)) ||
                      (!is.null(author_affiliation) && nzchar(author_affiliation))
  has_format_pref <- !is.null(default_notebook_format) && nzchar(default_notebook_format)

  if (has_author_info || has_format_pref) {
    config_path <- file.path(target_dir, "config.yml")
    if (file.exists(config_path)) {
      config_content <- readLines(config_path, warn = FALSE)

      # Update author section if provided
      if (has_author_info) {
        author_start <- grep("^  author:", config_content)
        if (length(author_start) > 0) {
          # Find where author section ends (next section at same indent level: "  <name>:")
          next_section_pattern <- "^  [a-z_]+:"
          all_sections <- grep(next_section_pattern, config_content)
          next_section <- all_sections[all_sections > author_start[1]]
          author_end <- if (length(next_section) > 0) next_section[1] - 1 else length(config_content)

          # Update author fields (looking for "    name:" - four spaces)
          for (i in author_start:author_end) {
            if (!is.null(author_name) && nzchar(author_name) && grepl("^    name:", config_content[i])) {
              config_content[i] <- sprintf("    name: \"%s\"", author_name)
            }
            if (!is.null(author_email) && nzchar(author_email) && grepl("^    email:", config_content[i])) {
              config_content[i] <- sprintf("    email: \"%s\"", author_email)
            }
            if (!is.null(author_affiliation) && nzchar(author_affiliation) && grepl("^    affiliation:", config_content[i])) {
              config_content[i] <- sprintf("    affiliation: \"%s\"", author_affiliation)
            }
          }
        }
      }

      # Update default_notebook_format if provided (root level)
      if (has_format_pref) {
        format_line <- grep("^  default_notebook_format:", config_content)
        if (length(format_line) > 0) {
          config_content[format_line[1]] <- sprintf("  default_notebook_format: %s", default_notebook_format)
        }
      }

      writeLines(config_content, config_path)
    }
  }

  # Initialization complete (config.yml serves as marker)
  message(sprintf("Project '%s' initialized successfully!", project_name))
}

#' Check if project is initialized
#'
#' Checks for existence of config.yml to determine initialization status.
#'
#' @param subdir Optional subdirectory to check.
#' @return Logical indicating if project is initialized.
#' @export
is_initialized <- function(subdir = NULL) {
  # Validate arguments
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)

  config_file <- if (!is.null(subdir) && nzchar(subdir)) file.path(subdir, "config.yml") else "config.yml"
  file.exists(config_file)
}

#' Remove initialization
#'
#' Removes config.yml to mark project as uninitialized.
#' WARNING: This will delete your project configuration!
#'
#' @param subdir Optional subdirectory to check.
#' @return Logical indicating if removal was successful.
#' @export
remove_init <- function(subdir = NULL) {
  # Validate arguments
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)

  config_file <- if (!is.null(subdir) && nzchar(subdir)) file.path(subdir, "config.yml") else "config.yml"
  if (file.exists(config_file)) {
    warning("Removing config.yml - your project configuration will be deleted!", call. = FALSE)
    unlink(config_file)
    TRUE
  } else {
    FALSE
  }
}

#' Recreate init.R for reference
#'
#' Generates an init.R file showing the initialization logic.
#' Useful for documentation and understanding how the project was set up.
#'
#' @param output_file Path where init.R should be written. Default: "init.R"
#' @return Invisibly returns TRUE on success
#' @export
#' @examples
#' \dontrun{
#' # Recreate init.R to see initialization logic
#' make_init()
#'
#' # Write to a different location
#' make_init("docs/init_reference.R")
#' }
make_init <- function(output_file = "init.R") {
  checkmate::assert_string(output_file, min.chars = 1)

  template_path <- system.file("templates/init.fr.R", package = "framework")
  if (!file.exists(template_path)) {
    stop("Template init.fr.R not found in package")
  }

  # Read template
  content <- readLines(template_path, warn = FALSE)

  # Add header explaining this is generated
  header <- c(
    "# This file was generated by make_init() for reference purposes.",
    "# It shows the initialization logic used by framework::init().",
    "# You can safely delete this file.",
    "",
    ""
  )

  content <- c(header, content)

  # Write file
  writeLines(content, output_file)
  message(sprintf("✓ Created %s", output_file))
  message("  This file shows initialization logic for reference.")
  message("  Placeholders like {{PROJECT_NAME}} would be replaced during actual init().")

  invisible(TRUE)
}

#' Remove .gitkeep files from data/ and functions/ directories
#' @keywords internal
.cleanup_gitkeep_files <- function(target_dir = ".") {
  # Find all .gitkeep files in data/ and functions/ directories
  data_gitkeeps <- list.files(
    path = file.path(target_dir, "data"),
    pattern = "^\\.gitkeep$",
    recursive = TRUE,
    full.names = TRUE,
    all.files = TRUE
  )

  functions_gitkeeps <- list.files(
    path = file.path(target_dir, "functions"),
    pattern = "^\\.gitkeep$",
    recursive = TRUE,
    full.names = TRUE,
    all.files = TRUE
  )

  all_gitkeeps <- c(data_gitkeeps, functions_gitkeeps)

  if (length(all_gitkeeps) > 0) {
    removed_count <- sum(file.remove(all_gitkeeps))
    if (removed_count > 0) {
      message(sprintf("\u2713 Cleaned up %d .gitkeep file%s", removed_count, if (removed_count == 1) "" else "s"))
    }
  }

  invisible(NULL)
}

#' Initialize git repository
#' @keywords internal
.init_git_repo <- function(target_dir = ".") {
  git_dir <- file.path(target_dir, ".git")

  if (file.exists(git_dir)) {
    return(invisible(NULL))
  }

  tryCatch({
    # Initialize git
    old_wd <- getwd()
    on.exit(setwd(old_wd), add = TRUE)

    if (!is.null(target_dir) && target_dir != ".") {
      setwd(target_dir)
    }

    # Initialize repo
    init_status <- system("git init", ignore.stdout = TRUE, ignore.stderr = TRUE)
    if (init_status != 0) {
      stop("git init failed")
    }

    # Add all files
    add_status <- system("git add .", ignore.stdout = TRUE, ignore.stderr = TRUE)
    if (add_status != 0) {
      stop("git add failed")
    }

    # Force-add .gitignore files in private directories (defense-in-depth)
    private_gitignores <- c(
      "data/source/private/.gitignore",
      "data/in_progress/private/.gitignore",
      "data/final/private/.gitignore",
      "results/private/.gitignore"
    )
    for (gitignore_path in private_gitignores) {
      if (file.exists(gitignore_path)) {
        system(paste0("git add -f ", gitignore_path), ignore.stdout = TRUE, ignore.stderr = TRUE)
      }
    }

    # Create initial commit
    commit_status <- system('git commit -m "Project initialized."', ignore.stdout = TRUE, ignore.stderr = TRUE)

    if (commit_status == 0) {
      message("\u2713 Git repository initialized with initial commit")
    } else {
      message("\u2713 Git repository initialized (commit skipped - you may need to configure git user)")
    }
  }, error = function(e) {
    message("Note: Could not initialize git repository. You can run 'git init' manually if needed.")
  })

  invisible(NULL)
}
