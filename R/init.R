#' Create init.R from template
#' @keywords internal
.create_init_file <- function(project_name, type, lintr, styler, subdir = NULL) {
  template_path <- system.file("templates/init.fr.R", package = "framework")
  if (!file.exists(template_path)) {
    stop("Template init.fr.R not found in package")
  }

  content <- readLines(template_path, warn = FALSE)

  # Replace placeholders
  content <- gsub("\\{\\{PROJECT_NAME\\}\\}", project_name, content)
  content <- gsub("\\{\\{PROJECT_TYPE\\}\\}", type, content)
  content <- gsub("\\{\\{LINTR\\}\\}", lintr, content)
  content <- gsub("\\{\\{STYLER\\}\\}", styler, content)

  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  target_file <- file.path(target_dir, "init.R")

  writeLines(content, target_file)
  message(sprintf("Created %s", target_file))
}

#' Create config.yml from template
#' @keywords internal
.create_config_file <- function(type = "analysis", attach_defaults = TRUE, subdir = NULL) {
  # Try type-specific template first, fall back to generic
  template_name <- sprintf("templates/config.%s.fr.yml", type)
  template_path <- system.file(template_name, package = "framework")

  if (!file.exists(template_path)) {
    # Fall back to generic template
    template_path <- system.file("templates/config.fr.yml", package = "framework")
    if (!file.exists(template_path)) {
      stop("Template config.fr.yml not found in package")
    }
  }

  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  target_file <- file.path(target_dir, "config.yml")

  # Read template content
  content <- readLines(template_path, warn = FALSE)

  # If attach_defaults is TRUE, replace the packages section with structured format
  if (attach_defaults) {
    # Find the packages section
    packages_start <- grep("^\\s*packages:", content)
    if (length(packages_start) > 0) {
      # Find where packages section ends (next section or end of file)
      section_headers <- grep("^\\s*[a-z_]+:", content)
      next_section <- section_headers[section_headers > packages_start[1]]
      packages_end <- if (length(next_section) > 0) next_section[1] - 1 else length(content)

      # Remove old packages section
      content <- content[-(packages_start:packages_end)]

      # Insert new structured packages section
      new_packages <- c(
        "  packages:",
        "    # Auto-attached packages (available without library() calls)",
        "    - name: dplyr",
        "      attached: true",
        "    - name: tidyr",
        "      attached: true",
        "    - name: ggplot2",
        "      attached: true",
        "    # Installed but not auto-attached (use library() when needed)",
        "    - name: readr",
        "      attached: false",
        "    - name: stringr",
        "      attached: false",
        "    - name: scales",
        "      attached: false",
        ""
      )

      # Insert at the packages_start position
      content <- c(
        content[1:(packages_start - 1)],
        new_packages,
        content[packages_start:length(content)]
      )
    }
  }

  # Write modified content
  writeLines(content, target_file)
  message(sprintf("Created %s", target_file))
}

#' Create .env from template
#' @keywords internal
.create_env_file <- function(subdir = NULL) {
  template_path <- system.file("templates/.env.fr", package = "framework")
  if (!file.exists(template_path)) {
    stop("Template .env.fr not found in package")
  }

  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  target_file <- file.path(target_dir, ".env")

  file.copy(template_path, target_file, overwrite = TRUE)
  message(sprintf("Created %s", target_file))
}

#' Create development .Rprofile
#' @keywords internal
.create_dev_rprofile <- function(subdir = NULL) {
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  target_file <- file.path(target_dir, ".Rprofile")

  # Get the user's home directory
  home_dir <- Sys.getenv("HOME")
  framework_dev_path <- file.path(home_dir, "code", "framework")

  rprofile_content <- sprintf('# Development .Rprofile for Framework
# Auto-generated by init(.dev_mode = TRUE)
# This .Rprofile overrides library() to load framework from development directory

# Store original library function
original_library <- base::library

# Override library function
library <- function(package, help = NULL, pos = 2, lib.loc = NULL,
                    character.only = FALSE, logical.return = FALSE,
                    warn.conflicts = TRUE, quietly = FALSE,
                    verbose = getOption("verbose")) {

  # Get the package name
  if (!character.only) {
    package <- as.character(substitute(package))
  }

  # If it\'s framework, use our custom loading
  if (package == "framework") {
    # First try to load from development directory
    dev_path <- "%s"
    if (dir.exists(dev_path)) {
      if (requireNamespace("devtools", quietly = TRUE)) {
        env <- devtools::load_all(dev_path, export_all = FALSE, quiet = TRUE)
        message("Framework loaded from development directory: ", dev_path)
        return(invisible(env))
      } else {
        warning("devtools package required for dev_mode. Install with: install.packages(\\"devtools\\")")
      }
    }

    # If not in development, try to load as installed package
    if (requireNamespace("framework", quietly = TRUE)) {
      original_library("framework", character.only = TRUE, quietly = quietly,
                      warn.conflicts = warn.conflicts)
      message("Framework loaded from installed package")
      return(invisible(TRUE))
    }

    warning("Framework not found - neither in ", dev_path, " nor as installed package")
    return(invisible(NULL))
  }

  # For all other packages, use the original library function
  original_library(package = package, help = help, pos = pos, lib.loc = lib.loc,
                  character.only = TRUE, logical.return = logical.return,
                  warn.conflicts = warn.conflicts, quietly = quietly,
                  verbose = verbose)
}

message("Framework dev mode active - will load from: %s")
', framework_dev_path, framework_dev_path)

  writeLines(rprofile_content, target_file)
  message(sprintf("Created development .Rprofile: %s", target_file))
  message(sprintf("  Framework will load from: %s", framework_dev_path))
}


#' Archive init.R after successful initialization
#' @keywords internal
.archive_init_file <- function(subdir = NULL) {
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  init_file <- file.path(target_dir, "init.R")
  archive_file <- file.path(target_dir, ".init.R.done")

  # Only archive if init.R exists
  if (!file.exists(init_file)) {
    return(invisible(NULL))
  }

  # Read original init.R content
  init_content <- tryCatch(
    readLines(init_file, warn = FALSE),
    error = function(e) {
      warning(sprintf("Could not read init.R for archiving: %s", e$message))
      return(NULL)
    }
  )

  if (is.null(init_content)) {
    return(invisible(NULL))
  }

  # Prepend documentation comment
  archive_content <- c(
    "# This file was used to initialize this project and can be safely deleted.",
    "# It's preserved here for documentation and reproducibility.",
    "# Original initialization command:",
    "#",
    init_content
  )

  # Write to hidden archive file
  tryCatch({
    writeLines(archive_content, archive_file)
    file.remove(init_file)
    message(sprintf("\u2713 Archived init.R to %s", basename(archive_file)))
  }, error = function(e) {
    warning(sprintf("Could not archive init.R: %s", e$message))
  })

  invisible(NULL)
}

#' Display next steps after initialization
#' @keywords internal
.display_next_steps <- function(project_name = NULL, type = "project", use_renv = FALSE) {
  cat("\n")
  cat("\u2713 Framework project initialized successfully!\n\n")

  # Show summary of settings
  cat("Project Configuration:\n")
  if (!is.null(project_name)) {
    cat(sprintf("  • Name: %s\n", project_name))
  }
  cat(sprintf("  • Type: %s\n", type))
  cat(sprintf("  • renv: %s\n", if (use_renv) "enabled" else "disabled"))
  cat("\n")

  cat("Next steps:\n")
  cat("  1. Review and edit config.yml\n")
  cat("  2. Add secrets to .env (gitignored)\n")
  cat("  3. Start a new R session in this directory\n")
  cat("  4. Run:\n")
  cat("       library(framework)\n")
  cat("       scaffold()\n")
  cat("  5. Start analyzing!\n\n")

  # Additional context based on project type
  if (type == "course") {
    cat("Course-specific features:\n")
    cat("  • lectures/ - For lecture materials and slides\n")
    cat("  • assignments/ - For student assignments\n")
    cat("  • Use make_notebook() to create student notebooks\n\n")
  } else if (type == "presentation") {
    cat("Presentation tips:\n")
    cat("  • Use make_notebook() to create your presentation\n")
    cat("  • Quarto reveal.js format recommended\n\n")
  }
}

#' Initialize the framework
#'
#' This function initializes the framework for a new project.
#' Can be run from the framework-project template OR from any empty directory.
#' When run from an empty directory, requires project_name and type parameters.
#'
#' @param project_name The name of the project (used for .Rproj file). Required when initializing from empty directory.
#' @param type The project type: "project" (default), "course", or "presentation".
#'   Replaces deprecated project_structure parameter.
#' @param project_structure DEPRECATED. Use 'type' parameter instead.
#'   For backward compatibility: "default"/"minimal" map to "project"/"presentation".
#' @param lintr The lintr style to use.
#' @param styler The styler style to use.
#' @param use_renv If TRUE, enables renv for package management. Default FALSE.
#' @param attach_defaults If TRUE, configures default packages to auto-attach on scaffold().
#'   Default packages: dplyr, tidyr, ggplot2 (auto-attached), readr, stringr, scales (installed only).
#'   Default TRUE.
#' @param subdir Optional subdirectory to copy files into. If provided, {subdir} in config files will be replaced with subdir/.
#' @param force If TRUE, will reinitialize even if project is already initialized.
#'
#' @examples
#' \dontrun{
#' # Initialize with explicit parameters
#' init(
#'   project_name = "MyProject",
#'   type = "project",
#'   use_renv = FALSE,
#'   attach_defaults = TRUE
#' )
#'
#' # Course project with renv enabled
#' init(
#'   project_name = "MyCourse",
#'   type = "course",
#'   use_renv = TRUE
#' )
#'
#' # Single presentation without default packages
#' init(type = "presentation", attach_defaults = FALSE)
#' }
#'
#' @export
init <- function(
    project_name = NULL,
    type = NULL,
    project_structure = NULL,
    lintr = NULL,
    styler = TRUE,
    use_renv = FALSE,
    attach_defaults = TRUE,
    author_name = NULL,
    author_email = NULL,
    author_affiliation = NULL,
    default_notebook_format = NULL,
    subdir = NULL,
    force = FALSE,
    .dev_mode = FALSE) {
  # Handle deprecated project_structure parameter
  if (!is.null(project_structure) && is.null(type)) {
    warning(
      "Parameter 'project_structure' is deprecated. Use 'type' instead.\n",
      "  Mapping: 'default' -> 'project', 'minimal' -> 'presentation'"
    )
    type <- switch(project_structure,
      "default" = "project",
      "minimal" = "presentation",
      "project"  # fallback
    )
  }

  # Handle deprecated "analysis" type
  if (!is.null(type) && type == "analysis") {
    warning(
      "Type 'analysis' is deprecated. Use 'project' instead.\n",
      "  The 'analysis' type will be removed in a future version."
    )
    type <- "project"
  }

  # Validate arguments
  checkmate::assert_string(project_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(type, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(project_structure, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(lintr, min.chars = 1, null.ok = TRUE)
  checkmate::assert(
    checkmate::check_flag(styler),
    checkmate::check_string(styler, min.chars = 1)
  )
  checkmate::assert_flag(use_renv)
  checkmate::assert_flag(attach_defaults)
  checkmate::assert_string(author_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_email, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_affiliation, min.chars = 1, null.ok = TRUE)
  # Handle empty string as NULL for validation
  if (!is.null(default_notebook_format) && nzchar(default_notebook_format)) {
    checkmate::assert_choice(default_notebook_format, c("quarto", "rmarkdown"))
  } else {
    default_notebook_format <- NULL
  }
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)
  checkmate::assert_flag(force)

  # Check if already initialized
  init_file <- if (!is.null(subdir) && nzchar(subdir)) file.path(subdir, ".initiated") else ".initiated"
  if (file.exists(init_file) && !force) {
    stop("Project already initialized. Use force = TRUE to reinitialize.")
  }

  # Detect if running from template (has init.R) or empty directory
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  from_template <- file.exists(file.path(target_dir, "init.R"))

  # If from empty directory, create necessary files first
  if (!from_template) {
    message("Initializing from empty directory...")

    # Require project_name and type
    if (is.null(project_name) || is.null(type)) {
      stop("project_name and type are required when initializing from an empty directory")
    }

    # Set defaults for optional parameters
    if (is.null(lintr)) lintr <- "default"
    # Handle styler TRUE/FALSE or string
    if (is.logical(styler)) {
      styler <- if (styler) "default" else FALSE
    } else if (is.null(styler)) {
      styler <- "default"
    }

    # Create foundational files
    .create_init_file(project_name, type, lintr, styler, subdir)
    .create_config_file(type, attach_defaults, subdir)
    .create_env_file(subdir)
  } else {
    # Set defaults from template behavior
    if (is.null(type)) type <- "project"
    if (is.null(lintr)) lintr <- "default"
    # Handle styler TRUE/FALSE or string
    if (is.logical(styler)) {
      styler <- if (styler) "default" else FALSE
    } else if (is.null(styler)) {
      styler <- "default"
    }
  }

  # Continue with standard init process
  .init_standard(project_name, type, lintr, styler, author_name, author_email, author_affiliation, default_notebook_format, subdir, force)

  # Enable renv if requested
  if (use_renv) {
    message("Enabling renv for this project...")
    renv_enable()
  }

  # Create dev mode .Rprofile if requested
  if (.dev_mode) {
    .create_dev_rprofile(subdir)
  }

  # Archive init.R after successful initialization
  .archive_init_file(subdir)

  # Display next steps if from empty directory
  if (!from_template) {
    .display_next_steps(project_name, type, use_renv)
  }
}

#' Standard initialization process (shared by both paths)
#' @keywords internal
.init_standard <- function(project_name, type, lintr, styler, author_name = NULL, author_email = NULL, author_affiliation = NULL, default_notebook_format = NULL, subdir, force) {
  # Validate arguments (already validated in init, but keep for internal calls)
  checkmate::assert_string(project_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(type, min.chars = 1)
  checkmate::assert_string(lintr, min.chars = 1)
  checkmate::assert_string(styler, min.chars = 1)
  checkmate::assert_string(author_name, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_email, min.chars = 1, null.ok = TRUE)
  checkmate::assert_string(author_affiliation, min.chars = 1, null.ok = TRUE)
  # Handle empty string as NULL
  if (!is.null(default_notebook_format) && !nzchar(default_notebook_format)) {
    default_notebook_format <- NULL
  }
  if (!is.null(default_notebook_format)) {
    checkmate::assert_choice(default_notebook_format, c("quarto", "rmarkdown"))
  }
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)
  checkmate::assert_flag(force)

  # Determine path for .initiated marker
  init_file <- if (!is.null(subdir) && nzchar(subdir)) file.path(subdir, ".initiated") else ".initiated"
  if (file.exists(init_file) && !force) {
    stop("Project already initialized. Use force = TRUE to reinitialize.")
  }

  # Derive project name
  if (!is.null(project_name)) {
    # Keep original capitalization, just convert spaces to hyphens for filenames
    rproj_name <- gsub("\\s+", "-", project_name)
  } else {
    project_name <- basename(getwd())
    rproj_name <- project_name
  }

  # Validate template style files
  lintr_template <- system.file("templates", paste0(".lintr.", lintr, ".fr"), package = "framework")
  styler_template <- system.file("templates", paste0(".styler.", styler, ".fr.R"), package = "framework")
  if (!file.exists(lintr_template)) stop(sprintf("Lintr style '%s' not found", lintr))
  if (!file.exists(styler_template)) stop(sprintf("Styler style '%s' not found", styler))

  # Remove existing *.Rproj file (only one per project)
  target_dir <- if (!is.null(subdir) && nzchar(subdir)) subdir else "."
  existing_rproj <- list.files(path = target_dir, pattern = "\\.Rproj$", full.names = TRUE)
  if (length(existing_rproj)) file.remove(existing_rproj)

  # Copy and rename .Rproj file
  rproj_template <- system.file("templates", "project.fr.Rproj", package = "framework")
  if (!file.exists(rproj_template)) stop("Template project.fr.Rproj file not found in package.")
  rproj_target <- file.path(target_dir, paste0(rproj_name, ".Rproj"))
  file.copy(rproj_template, rproj_target, overwrite = TRUE)

  # Create IDE configuration files (VS Code workspace and settings)
  .create_ide_configs(rproj_name, target_dir, python = FALSE)

  # Copy and rename other template files
  template_dir <- system.file("templates", package = "framework")
  template_files <- list.files(template_dir, full.names = TRUE, all.files = TRUE, no.. = TRUE)

  for (file in template_files) {
    fname <- basename(file)

    # Skip files already handled explicitly
    if (fname == "project.fr.Rproj") next
    if (fname == "init.fr.R") next  # Skip init.R template (handled separately in empty dir case)
    if (fname == ".env.fr") next  # Skip .env template (handled separately in empty dir case)
    if (fname == "test.fr.R") next  # Skip test file template

    # Skip type-specific config and README files (these are handled separately)
    if (grepl("^config\\.(project|course|presentation)\\.fr\\.yml$", fname)) next
    if (grepl("^README\\.(project|course|presentation)\\.fr\\.md$", fname)) next
    if (fname == "config.fr.yml") next  # Skip generic config (handled separately)

    if (!grepl("\\.fr($|\\.)", fname)) next

    # Replace `.fr.` with `.` or `.fr` suffix with nothing
    new_name <- gsub("\\.fr\\.", ".", fname)
    new_name <- gsub("\\.fr$", "", new_name)
    # Remove .default from lintr and styler files (both in middle and end)
    new_name <- gsub("\\.default\\.", ".", new_name)
    new_name <- gsub("\\.default$", "", new_name)

    # Preserve leading dot
    if (grepl("^\\.", fname)) {
      new_name <- paste0(".", sub("^\\.", "", new_name))
    }

    target_path <- file.path(target_dir, new_name)
    dir.create(dirname(target_path), showWarnings = FALSE, recursive = TRUE)

    success <- file.copy(file, target_path, overwrite = TRUE)
    if (!success) warning(sprintf("Failed to copy template file: %s to %s", file, target_path))

    # Substitute {subdir} in YAML-like config files
    if (grepl("\\.ya?ml$", new_name)) {
      content <- readLines(target_path)
      subdir_prefix <- if (!is.null(subdir) && nzchar(subdir)) paste0(subdir, "/") else ""
      content <- gsub("\\{subdir\\}", subdir_prefix, content)
      writeLines(content, target_path)
    }
  }

  # Copy project structure
  structure_dir <- system.file("project_structure", type, package = "framework")
  if (!dir.exists(structure_dir)) stop(sprintf("Project type '%s' not found", type))

  all_dirs <- list.dirs(structure_dir, recursive = TRUE, full.names = TRUE)
  all_dirs <- all_dirs[all_dirs != structure_dir]

  for (dir in all_dirs) {
    rel_path <- sub(paste0("^", structure_dir, "/?"), "", dir)
    target_path <- file.path(target_dir, rel_path)
    dir.create(target_path, showWarnings = FALSE, recursive = TRUE)
  }

  structure_files <- list.files(structure_dir, recursive = TRUE, full.names = TRUE)
  for (file in structure_files) {
    if (basename(file) == ".gitkeep") next
    rel_path <- sub(paste0("^", structure_dir, "/?"), "", file)
    target_path <- file.path(target_dir, rel_path)
    file.copy(file, target_path, overwrite = TRUE)
  }

  # Copy .env.example to .env if present
  env_example <- file.path(target_dir, ".env.example")
  if (file.exists(env_example)) {
    file.copy(env_example, file.path(target_dir, ".env"), overwrite = TRUE)
  }

  # Copy type-specific README → README.md
  readme_template <- system.file("templates", sprintf("README.%s.fr.md", type), package = "framework")
  if (!file.exists(readme_template)) {
    # Fall back to generic README if type-specific doesn't exist
    readme_template <- system.file("templates", "README.fr.md", package = "framework")
  }
  if (file.exists(readme_template)) {
    readme_path <- file.path(target_dir, "README.md")
    file.copy(readme_template, readme_path, overwrite = TRUE)
  }

  # Update config.yml with author information and notebook format if provided
  has_author_info <- (!is.null(author_name) && nzchar(author_name)) ||
                      (!is.null(author_email) && nzchar(author_email)) ||
                      (!is.null(author_affiliation) && nzchar(author_affiliation))
  has_format_pref <- !is.null(default_notebook_format) && nzchar(default_notebook_format)

  if (has_author_info || has_format_pref) {
    config_path <- file.path(target_dir, "config.yml")
    if (file.exists(config_path)) {
      config_content <- readLines(config_path, warn = FALSE)

      # Update author section if provided
      if (has_author_info) {
        author_start <- grep("^  author:", config_content)
        if (length(author_start) > 0) {
          # Find where author section ends (next section at same indent level: "  <name>:")
          next_section_pattern <- "^  [a-z_]+:"
          all_sections <- grep(next_section_pattern, config_content)
          next_section <- all_sections[all_sections > author_start[1]]
          author_end <- if (length(next_section) > 0) next_section[1] - 1 else length(config_content)

          # Update author fields (looking for "    name:" - four spaces)
          for (i in author_start:author_end) {
            if (!is.null(author_name) && nzchar(author_name) && grepl("^    name:", config_content[i])) {
              config_content[i] <- sprintf("    name: \"%s\"", author_name)
            }
            if (!is.null(author_email) && nzchar(author_email) && grepl("^    email:", config_content[i])) {
              config_content[i] <- sprintf("    email: \"%s\"", author_email)
            }
            if (!is.null(author_affiliation) && nzchar(author_affiliation) && grepl("^    affiliation:", config_content[i])) {
              config_content[i] <- sprintf("    affiliation: \"%s\"", author_affiliation)
            }
          }
        }
      }

      # Update default_notebook_format if provided (root level)
      if (has_format_pref) {
        format_line <- grep("^  default_notebook_format:", config_content)
        if (length(format_line) > 0) {
          config_content[format_line[1]] <- sprintf("  default_notebook_format: %s", default_notebook_format)
        }
      }

      writeLines(config_content, config_path)
    }
  }

  # Mark as initialized
  writeLines(as.character(Sys.time()), file.path(target_dir, ".initiated"))
  message(sprintf("Project '%s' initialized successfully!", project_name))
}

#' Check if project is initialized
#'
#' @param subdir Optional subdirectory to check.
#' @return Logical indicating if project is initialized.
#' @export
is_initialized <- function(subdir = NULL) {
  # Validate arguments
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)

  init_file <- if (!is.null(subdir) && nzchar(subdir)) file.path(subdir, ".initiated") else ".initiated"
  file.exists(init_file)
}

#' Remove initialization
#'
#' @param subdir Optional subdirectory to check.
#' @return Logical indicating if removal was successful.
#' @export
remove_init <- function(subdir = NULL) {
  # Validate arguments
  checkmate::assert_string(subdir, min.chars = 1, null.ok = TRUE)

  init_file <- if (!is.null(subdir) && nzchar(subdir)) file.path(subdir, ".initiated") else ".initiated"
  if (file.exists(init_file)) {
    unlink(init_file)
    TRUE
  } else {
    FALSE
  }
}
