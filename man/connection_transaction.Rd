% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transactions.R
\name{connection_transaction}
\alias{connection_transaction}
\title{Execute code within a database transaction}
\usage{
connection_transaction(conn, code)
}
\arguments{
\item{conn}{Database connection}

\item{code}{Expression or code block to execute within the transaction}
}
\value{
The result of the code expression
}
\description{
Wraps code execution in a database transaction with automatic
commit on success and rollback on error. This ensures atomicity
of multiple database operations.
}
\details{
The function automatically:
\itemize{
\item Begins a transaction with \code{DBI::dbBegin()}
\item Executes the provided code
\item Commits the transaction on success with \code{DBI::dbCommit()}
\item Rolls back the transaction on error with \code{DBI::dbRollback()}
}

Transactions are essential for maintaining data integrity when performing
multiple related operations. If any operation fails, all changes are rolled back.
}
\examples{
\dontrun{
conn <- connection_get("postgres")

# Basic transaction
connection_transaction(conn, {
  connection_insert(conn, "users", list(name = "Alice", age = 30))
  connection_insert(conn, "users", list(name = "Bob", age = 25))
})

# Transaction with return value
result <- connection_transaction(conn, {
  id <- connection_insert(conn, "users", list(name = "Charlie", age = 35))
  user <- connection_find(conn, "users", id)
  user
})

# Transaction with error handling
tryCatch({
  connection_transaction(conn, {
    connection_insert(conn, "users", list(name = "Invalid"))
    stop("Something went wrong")  # This will trigger rollback
  })
}, error = function(e) {
  message("Transaction failed: ", e$message)
})

DBI::dbDisconnect(conn)
}

}
